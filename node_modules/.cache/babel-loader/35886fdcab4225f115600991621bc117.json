{"ast":null,"code":"import { initialState } from \"../reducers/algorithm\";\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\"\n};\n\nconst sleep = ms => new Promise(res => setTimeout(res, ms));\n\nconst homeInfection = async (grid, scenario, targetDay, dispatch) => {\n  console.log(\"targetDay\", targetDay);\n  debugger;\n\n  if (targetDay !== null) {\n    const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n    grid = [...initialState[dataKey]];\n    console.log(\"grid\", grid);\n  }\n\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0\n    });\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  }\n\n  const direction = [[0, -1], [0, 1], [-1, 0], [1, 0]];\n\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n\n    zombieHomes = infectionProgress;\n    day++;\n    console.log(\"day\", day);\n\n    if (targetDay !== null && targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n    }\n\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n      await sleep(1000);\n    }\n  }\n\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid = scenario === 0 ? getState().AlgorithmReducer.firstScenarioData : getState().AlgorithmReducer.secondScenarioData;\n  homeInfection(grid, scenario, day, dispatch);\n};","map":{"version":3,"sources":["/Users/khristina/Documents/front-end/interview-homework/src/redux/actions/algorithmActions.js"],"names":["initialState","AlgorithmActions","INFECT_HOMES","sleep","ms","Promise","res","setTimeout","homeInfection","grid","scenario","targetDay","dispatch","console","log","dataKey","type","day","healthyHouses","zombieHomes","i","length","j","push","direction","infectionProgress","x","y","pop","x2","y2","InfectHomes","getState","AlgorithmReducer","firstScenarioData","secondScenarioData"],"mappings":"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","sourcesContent":["import { initialState } from \"../reducers/algorithm\";\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\",\n};\n\nconst sleep = (ms) => new Promise((res) => setTimeout(res, ms));\n\nconst homeInfection = async (grid, scenario, targetDay, dispatch) => {\n  console.log(\"targetDay\", targetDay);\n  debugger;\n  if (targetDay !== null) {\n    const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n    grid = [...initialState[dataKey]];\n    console.log(\"grid\", grid);\n  }\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0,\n    });\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  }\n  const direction = [\n    [0, -1],\n    [0, 1],\n    [-1, 0],\n    [1, 0],\n  ];\n\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n    zombieHomes = infectionProgress;\n    day++;\n    console.log(\"day\", day);\n    if (targetDay !== null && targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n    }\n\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n      await sleep(1000);\n    }\n  }\n\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid =\n    scenario === 0\n      ? getState().AlgorithmReducer.firstScenarioData\n      : getState().AlgorithmReducer.secondScenarioData;\n\n  homeInfection(grid, scenario, day, dispatch);\n};\n"]},"metadata":{},"sourceType":"module"}
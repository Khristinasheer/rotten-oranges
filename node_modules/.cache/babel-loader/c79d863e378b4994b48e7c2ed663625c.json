{"ast":null,"code":"import { cloneDeep } from \"lodash\";\nimport { initialState } from \"../reducers/algorithm\";\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\"\n};\n\nconst sleep = ms => new Promise(res => setTimeout(res, ms));\n\nconst homeInfection = async (initialGrid, scenario, targetDay, dispatch) => {\n  const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n  const grid = cloneDeep(initialState[dataKey]); // console.log(\"targetDay\", targetDay);\n  // console.log(\"grid\", grid);\n\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0\n    });\n    return 0;\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  } //debugger;\n\n\n  const direction = [[0, -1], [0, 1], [-1, 0], [1, 0]]; // console.log(\"healrthy houses/zombie homes\", healthyHouses, zombieHomes);\n\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n\n    zombieHomes = infectionProgress;\n    day++; // console.log(\"day\", day);\n\n    if (targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n      break;\n    }\n\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n      await sleep(1000);\n    }\n  }\n\n  if (healthyHouses) {\n    grid;\n    console.log({\n      grid\n    });\n    if (grid[i][j] === 2) zombieHomes.push([1, 1]);\n  }\n\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid = scenario === 0 ? getState().AlgorithmReducer.firstScenarioData : getState().AlgorithmReducer.secondScenarioData;\n  homeInfection(grid, scenario, day, dispatch);\n};","map":{"version":3,"sources":["/Users/khristina/Documents/interview-homework/src/redux/actions/algorithmActions.js"],"names":["cloneDeep","initialState","AlgorithmActions","INFECT_HOMES","sleep","ms","Promise","res","setTimeout","homeInfection","initialGrid","scenario","targetDay","dispatch","dataKey","grid","type","day","healthyHouses","zombieHomes","i","length","j","push","direction","infectionProgress","x","y","pop","x2","y2","console","log","InfectHomes","getState","AlgorithmReducer","firstScenarioData","secondScenarioData"],"mappings":"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","sourcesContent":["import { cloneDeep } from \"lodash\";\nimport { initialState } from \"../reducers/algorithm\";\n\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\",\n};\n\nconst sleep = (ms) => new Promise((res) => setTimeout(res, ms));\n\nconst homeInfection = async (initialGrid, scenario, targetDay, dispatch) => {\n  const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n  const grid = cloneDeep(initialState[dataKey]);\n  // console.log(\"targetDay\", targetDay);\n  // console.log(\"grid\", grid);\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0,\n    });\n    return 0;\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  }\n\n  //debugger;\n  const direction = [\n    [0, -1],\n    [0, 1],\n    [-1, 0],\n    [1, 0],\n  ];\n  // console.log(\"healrthy houses/zombie homes\", healthyHouses, zombieHomes);\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n\n    zombieHomes = infectionProgress;\n    day++;\n    // console.log(\"day\", day);\n    if (targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n      break;\n    }\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n      await sleep(1000);\n    }\n  }\n\n  if (healthyHouses) {\n    grid;\n    console.log({ grid });\n    if (grid[i][j] === 2) zombieHomes.push([1, 1]);\n  }\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid =\n    scenario === 0\n      ? getState().AlgorithmReducer.firstScenarioData\n      : getState().AlgorithmReducer.secondScenarioData;\n\n  homeInfection(grid, scenario, day, dispatch);\n};\n"]},"metadata":{},"sourceType":"module"}
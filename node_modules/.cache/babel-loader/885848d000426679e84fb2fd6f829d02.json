{"ast":null,"code":"// import { initialState } from \"../reducers/algorithm\";\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\"\n};\nconst initialState = {\n  firstScenarioData: [[1, 0, 1, 1, 0, 2], [1, 1, 1, 2, 1, 0], [0, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 2], [2, 0, 1, 0, 1, 0]],\n  secondScenarioData: [[2, 0, 1, 0, 1, 2], [1, 0, 0, 1, 0, 1], [0, 0, 1, 0, 1, 1], [2, 0, 1, 1, 0, 2], [1, 0, 0, 0, 1, 0], [2, 1, 0, 0, 2, 0]],\n  firstScenarioDay: 0,\n  secondScenarioDay: 0\n};\n\nconst sleep = ms => new Promise(res => setTimeout(res, ms));\n\nconst homeInfection = async (initialGrid, scenario, targetDay, dispatch) => {\n  const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n  const grid = [...initialState[dataKey]];\n\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0\n    });\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  } //debugger;\n\n\n  const direction = [[0, -1], [0, 1], [-1, 0], [1, 0]];\n\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n\n    zombieHomes = infectionProgress;\n    day++;\n\n    if (targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n      break;\n    }\n\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day\n      });\n      await sleep(1000);\n    }\n  }\n\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid = scenario === 0 ? getState().AlgorithmReducer.firstScenarioData : getState().AlgorithmReducer.secondScenarioData;\n  homeInfection(grid, scenario, day, dispatch);\n};","map":{"version":3,"sources":["/Users/khristina/Documents/front-end/interview-homework/src/redux/actions/algorithmActions.js"],"names":["AlgorithmActions","INFECT_HOMES","initialState","firstScenarioData","secondScenarioData","firstScenarioDay","secondScenarioDay","sleep","ms","Promise","res","setTimeout","homeInfection","initialGrid","scenario","targetDay","dispatch","dataKey","grid","type","day","healthyHouses","zombieHomes","i","length","j","push","direction","infectionProgress","x","y","pop","x2","y2","InfectHomes","getState","AlgorithmReducer"],"mappings":"AAAA;AACA,OAAO,MAAMA,gBAAgB,GAAG;AAC9BC,EAAAA,YAAY,EAAE;AADgB,CAAzB;AAIP,MAAMC,YAAY,GAAG;AACnBC,EAAAA,iBAAiB,EAAE,CACjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CADiB,EAEjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAFiB,EAGjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAHiB,EAIjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAJiB,EAKjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CALiB,EAMjB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CANiB,CADA;AASnBC,EAAAA,kBAAkB,EAAE,CAClB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CADkB,EAElB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAFkB,EAGlB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAHkB,EAIlB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAJkB,EAKlB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CALkB,EAMlB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CANkB,CATD;AAkBnBC,EAAAA,gBAAgB,EAAE,CAlBC;AAmBnBC,EAAAA,iBAAiB,EAAE;AAnBA,CAArB;;AAsBA,MAAMC,KAAK,GAAIC,EAAD,IAAQ,IAAIC,OAAJ,CAAaC,GAAD,IAASC,UAAU,CAACD,GAAD,EAAMF,EAAN,CAA/B,CAAtB;;AAEA,MAAMI,aAAa,GAAG,OAAOC,WAAP,EAAoBC,QAApB,EAA8BC,SAA9B,EAAyCC,QAAzC,KAAsD;AAC1E,QAAMC,OAAO,GAAGH,QAAQ,KAAK,CAAb,GAAiB,mBAAjB,GAAuC,oBAAvD;AACA,QAAMI,IAAI,GAAG,CAAC,GAAGhB,YAAY,CAACe,OAAD,CAAhB,CAAb;;AAEA,MAAIF,SAAS,KAAK,CAAlB,EAAqB;AACnBC,IAAAA,QAAQ,CAAC;AACPG,MAAAA,IAAI,EAAEnB,gBAAgB,CAACC,YADhB;AAEPa,MAAAA,QAFO;AAGPI,MAAAA,IAHO;AAIPE,MAAAA,GAAG,EAAE;AAJE,KAAD,CAAR;AAMD;;AAED,MAAIA,GAAG,GAAG,CAAV;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAACM,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACK,CAAD,CAAJ,CAAQC,MAA5B,EAAoCC,CAAC,EAArC,EAAyC;AACvC,UAAIP,IAAI,CAACK,CAAD,CAAJ,CAAQE,CAAR,MAAe,CAAnB,EAAsBJ,aAAa;AACnC,UAAIH,IAAI,CAACK,CAAD,CAAJ,CAAQE,CAAR,MAAe,CAAnB,EAAsBH,WAAW,CAACI,IAAZ,CAAiB,CAACH,CAAD,EAAIE,CAAJ,CAAjB;AACvB;AACF,GAtByE,CAwB1E;;;AACA,QAAME,SAAS,GAAG,CAChB,CAAC,CAAD,EAAI,CAAC,CAAL,CADgB,EAEhB,CAAC,CAAD,EAAI,CAAJ,CAFgB,EAGhB,CAAC,CAAC,CAAF,EAAK,CAAL,CAHgB,EAIhB,CAAC,CAAD,EAAI,CAAJ,CAJgB,CAAlB;;AAOA,SAAON,aAAa,IAAIC,WAAW,CAACE,MAApC,EAA4C;AAC1C,QAAII,iBAAiB,GAAG,EAAxB;;AACA,WAAON,WAAW,CAACE,MAAnB,EAA2B;AACzB,UAAI,CAACK,CAAD,EAAIC,CAAJ,IAASR,WAAW,CAACS,GAAZ,EAAb;;AACA,WAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,YAAI,CAACS,EAAD,EAAKC,EAAL,IAAW,CAACJ,CAAC,GAAGF,SAAS,CAACJ,CAAD,CAAT,CAAa,CAAb,CAAL,EAAsBO,CAAC,GAAGH,SAAS,CAACJ,CAAD,CAAT,CAAa,CAAb,CAA1B,CAAf;;AACA,YAAIL,IAAI,CAACc,EAAD,CAAJ,IAAYd,IAAI,CAACc,EAAD,CAAJ,CAASC,EAAT,MAAiB,CAAjC,EAAoC;AAClCf,UAAAA,IAAI,CAACc,EAAD,CAAJ,CAASC,EAAT,IAAe,CAAf;AACAZ,UAAAA,aAAa;AACbO,UAAAA,iBAAiB,CAACF,IAAlB,CAAuB,CAACM,EAAD,EAAKC,EAAL,CAAvB;AACD;AACF;AACF;;AAEDX,IAAAA,WAAW,GAAGM,iBAAd;AACAR,IAAAA,GAAG;;AAEH,QAAIL,SAAS,KAAKK,GAAlB,EAAuB;AACrBJ,MAAAA,QAAQ,CAAC;AACPG,QAAAA,IAAI,EAAEnB,gBAAgB,CAACC,YADhB;AAEPa,QAAAA,QAFO;AAGPI,QAAAA,IAHO;AAIPE,QAAAA;AAJO,OAAD,CAAR;AAMA;AACD;;AAED,QAAIL,SAAS,KAAK,IAAlB,EAAwB;AACtBC,MAAAA,QAAQ,CAAC;AACPG,QAAAA,IAAI,EAAEnB,gBAAgB,CAACC,YADhB;AAEPa,QAAAA,QAFO;AAGPI,QAAAA,IAHO;AAIPE,QAAAA;AAJO,OAAD,CAAR;AAMA,YAAMb,KAAK,CAAC,IAAD,CAAX;AACD;AACF;;AAED,SAAOa,GAAP;AACD,CAvED;;AAyEA,OAAO,MAAMc,WAAW,GAAG,CAACpB,QAAD,EAAWM,GAAG,GAAG,IAAjB,KAA0B,CAACJ,QAAD,EAAWmB,QAAX,KAAwB;AAC3E,QAAMjB,IAAI,GACRJ,QAAQ,KAAK,CAAb,GACIqB,QAAQ,GAAGC,gBAAX,CAA4BjC,iBADhC,GAEIgC,QAAQ,GAAGC,gBAAX,CAA4BhC,kBAHlC;AAKAQ,EAAAA,aAAa,CAACM,IAAD,EAAOJ,QAAP,EAAiBM,GAAjB,EAAsBJ,QAAtB,CAAb;AACD,CAPM","sourcesContent":["// import { initialState } from \"../reducers/algorithm\";\nexport const AlgorithmActions = {\n  INFECT_HOMES: \"INFECT_HOMES\",\n};\n\nconst initialState = {\n  firstScenarioData: [\n    [1, 0, 1, 1, 0, 2],\n    [1, 1, 1, 2, 1, 0],\n    [0, 0, 1, 0, 1, 1],\n    [1, 0, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1, 2],\n    [2, 0, 1, 0, 1, 0],\n  ],\n  secondScenarioData: [\n    [2, 0, 1, 0, 1, 2],\n    [1, 0, 0, 1, 0, 1],\n    [0, 0, 1, 0, 1, 1],\n    [2, 0, 1, 1, 0, 2],\n    [1, 0, 0, 0, 1, 0],\n    [2, 1, 0, 0, 2, 0],\n  ],\n\n  firstScenarioDay: 0,\n  secondScenarioDay: 0,\n};\n\nconst sleep = (ms) => new Promise((res) => setTimeout(res, ms));\n\nconst homeInfection = async (initialGrid, scenario, targetDay, dispatch) => {\n  const dataKey = scenario === 0 ? \"firstScenarioData\" : \"secondScenarioData\";\n  const grid = [...initialState[dataKey]];\n\n  if (targetDay === 0) {\n    dispatch({\n      type: AlgorithmActions.INFECT_HOMES,\n      scenario,\n      grid,\n      day: 0,\n    });\n  }\n\n  let day = 0;\n  let healthyHouses = 0;\n  let zombieHomes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) healthyHouses++;\n      if (grid[i][j] === 2) zombieHomes.push([i, j]);\n    }\n  }\n\n  //debugger;\n  const direction = [\n    [0, -1],\n    [0, 1],\n    [-1, 0],\n    [1, 0],\n  ];\n\n  while (healthyHouses && zombieHomes.length) {\n    let infectionProgress = [];\n    while (zombieHomes.length) {\n      let [x, y] = zombieHomes.pop();\n      for (let i = 0; i < 4; i++) {\n        let [x2, y2] = [x + direction[i][0], y + direction[i][1]];\n        if (grid[x2] && grid[x2][y2] === 1) {\n          grid[x2][y2] = 2;\n          healthyHouses--;\n          infectionProgress.push([x2, y2]);\n        }\n      }\n    }\n\n    zombieHomes = infectionProgress;\n    day++;\n\n    if (targetDay === day) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n      break;\n    }\n\n    if (targetDay === null) {\n      dispatch({\n        type: AlgorithmActions.INFECT_HOMES,\n        scenario,\n        grid,\n        day,\n      });\n      await sleep(1000);\n    }\n  }\n\n  return day;\n};\n\nexport const InfectHomes = (scenario, day = null) => (dispatch, getState) => {\n  const grid =\n    scenario === 0\n      ? getState().AlgorithmReducer.firstScenarioData\n      : getState().AlgorithmReducer.secondScenarioData;\n\n  homeInfection(grid, scenario, day, dispatch);\n};\n"]},"metadata":{},"sourceType":"module"}